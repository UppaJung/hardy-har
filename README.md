# Hardy-Har: A Hardy HTTP Archive (HAR) Generator 

[HTTP Archives](http://www.softwareishard.com/blog/har-12-spec) (HARs) are the de-facto[^frozen] standard for exporting network debugger logs from browsers. The acronym HAR is used to refer to both the JSON format object data format and the files into which the format is written with the extension `.har`.[^hardy-har-har]

This module will generate HTTP Archives in HAR format from `Page.` and `Network.` debugger events generated by the [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol)[^cdp]. These events can be observed by browser extensions and via headless browser tools such as Puppeteer.

`hardy-har` is backwards compatible with the [`chrome-har`](https://github.com/sitespeedio/chrome-har) API, from which it still borrows a small amount of code and a huge amount of expertise.[^port-or-rewrite] It differs in that it is written entirely in TypeScript using a declarative style so that the code for each value produced appears only once, in hopes that this will make the code hardier and easier to maintain. `hardy-har` also includes WebSocket frames in the archives it generates.

### Sample Use

#### Strongly-typed
```typescript
// requires types from npm:@types/chrome
import {
  type HarEvent,
  type HarEventNameAndObject,
  type DevToolsProtocolGetResponseBodyRequest,
  type DevToolsProtocolGetResponseBodyResponse,
  GetResponseBodyResponseMetaEventName,
  isHarEventName,
  harFromNamedDebuggerEvents,
} from "jsr:@stuartschechter/hardy-har";

export const recordBrowserTabToHarFromWithinExtension = async (
  tabId: number,
  executeBrowserTaskToRecord: () => Promise<void>
) => {
  const debuggerEventArray = [] as HarEventNameAndObject[]; 
  
  const onDebugEvent = async (source: chrome.debugger.Debuggee, eventName: string, event: unknown) => {
    // Ignore debugger events for other tabs
    if (source.tabId !== tabId) return;
    // Ignore events that aren't needed to generate HARs 
    if (!isHarEventName(eventName)) return;
    debuggerEventArray.push({eventName, event: event as HarEvent<typeof eventName>});

    if (eventName === 'Network.loadingFinished') {
      // The chrome Network protocol doesn't provide response bodies unless you ask.
      const requestId = (event as HarEvent<typeof eventName>).requestId;
      // Request the response body
      const responseBodyObj = (await (chrome.debugger.sendCommand(
        {tabId},
        "Network.getResponseBody",
        {requestId} satisfies DevToolsProtocolGetResponseBodyRequest)
      )) as DevToolsProtocolGetResponseBodyResponse | undefined;
      if (responseBodyObj != null) {
        // Record a meta event consisting of the requestId and the response body, as if the Chrome DevTools protocol
        // had been generous enough to volunteer this information without us begging for it.
        debuggerEventArray.push({
          eventName: GetResponseBodyResponseMetaEventName,
          event: {requestId, ...responseBodyObj} satisfies HarEvent<typeof GetResponseBodyResponseMetaEventName>
        });
      }
    }		
  }

  try {
    await chrome.debugger.attach({tabId}, '1.3');
    await chrome.debugger.sendCommand({tabId}, "Page.enable");
    await chrome.debugger.sendCommand({tabId}, "Network.enable");
    chrome.debugger.onEvent.addListener(onDebugEvent);

    await executeBrowserTaskToRecord();
    return harFromNamedDebuggerEvents(debuggerEventArray);

  } finally {
    await chrome.debugger.detach({tabId});
  }
}
```

#### As a drop-in replacement for chrome-har

Just replace `harFromMessages` with `harFromChromeHarMessageParamsObjects`.
If you capture response bodies and attach them to another Network event,
as you would for `chrome-har`, `hardy-har` will still find them.

```javascript
import {harFromChromeHarMessageParamsObjects} from "jsr:@stuartschechter/hardy-har";

// ... follow chrome-har example to generate events and options

harFromChromeHarMessageParamsObjects(harEvents, options);
```



[^frozen]: The standard is "frozen" though supports extensions made by adding fields starting with underscores (`_`). Such extensions are how the "frozen" standard was extended by the Chrome Team to support Web Sockets.

[^hardy-har-har]: By implication, one might refer to a HTTP Archive file generated by this module as a hardy-har .har.

[^port-or-rewrite]: Whether `hardy-har` is a port or re-write of `chrome-har` is a question made largely irrelevant by the `chrome-har` team's generous use of the MIT License. Regardless, they are owed much gratitude.
